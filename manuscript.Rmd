---
title: "A Hitchhiker's Guide to Reproducible Research" # replace with something serious
output: bookdown::pdf_document2
repro:
  packages:
    - usethis
    - aaronpeikert/repro@7bfaf98
    - here
    - rstudio/webshot2@f62e743
csl: apa7.csl
numbered_headings: true
toc_depth: 5
bibliography: references.bib
---

<!-- the HTML comments, like this one, are meta comments, mainly describing the intent --->
<!-- each sentence below a heading summarizes what I want to say there --->
<!-- "Hands-on:" means concrete practical application, they roughly proceed from easy/familiar to hard/unfamiliar-->

```{r setup, include=FALSE}
library(repro)
source(here::here("R", "link.R"))
```

# Why you should care about reproducibility

<!-- define reproducibility -->
<!-- is a direct quote from my master thesis -->
<!-- I wouldn't want to cite it. @brandmaier, would you please rewrite? -->
A reproducible scientific product allows other researchers to obtain the same results from the same dataset in a way that enables substantive criticism and therefore facilitates replication.
<!-- lure the reader in -->
This notion of independent verifiability has long been part of "good scientific practice", but has not reached its full potential to benefit the scientific community.
<!-- expand: who is calling it a requirement, maybe metascientific arguments-->
Reproducing an empirical study is often tedious and frustrating work for the researcher.
However, if reproduction would require mere minutes instead of hours, it could greatly facilitate collaboration within and across research projects.
<!-- Guiding principle: spending machine compute time instead of human research time -->
To archive this boost, we must place the burden of reproducing something upon computers instead of human researchers.
A scientific document should therefore be understood by researchers but reproduced by computers.

This tutorial walks through the creation of such a document that can be reproduced automatically.
Though reproducibility is but a small part of the research process, it can serve as the mortar of open science building blocks (e.g. preregistration, open data, postpublication review).
Therefore, we show the whole lifecycle of an open research project, where some parts are essential to archive reproducibility.
All code chunks are meant for the reader to try out for themselves.
Still, the reader can safely skip sections marked as optional, when unfit for their research question or methods.
However, any empirical data analysis will suffer from the following threats to reproducibility:
<!-- Which problems are solved by which tool (like in Andreas talk)-->
<!--stolen from: https://brandmaier.github.io/reproducible-data-analysis-materials/KULeuvenQuantPsy2020.html#11 -->

1. Multiple versions of scripts/data (e.g., the dataset has changed over time, i.e., was further cleaned or extended)
2. Copy&paste errors (e.g., inconsistency between reported result and reproduced result)
3. unclear which scripts should be executed in which order
4. Broken software dependencies (e.g., analysis broken after an update, missing package)

It is common to rely on the craftiness of the researcher to debug these problems, but we could prevent them altogether with:

1. Version control
2. Dynamic document creation
3. Dependency tracking
4. Software management

We deem each concept necessary to archive longterm reproducibility.
However, which tools you use to implement these concepts is a matter of taste and project requirements.
This tutorial will follow the recommendations of @Peikert2019 and utilize Git for version control, RMarkdown for dynamic document creation, Make for dependency tracking, and Docker for software management.
Their interplay is shown in Figure \@ref(fig:schematic).
At several points, we suggest other viable alternatives.

```{r schematic, eval = TRUE, echo = FALSE, fig.cap="Schematic illustration of the interplay of the four components (in dashed boxes) central to the reproducible workflow: version control (Git), dependency management (Make), software management (Docker), and dynamic document generation (R Markdown). Git tracks changes to the project over time. Make manages dependencies among the files. Docker provides a container in which the final report is built using dynamic document generation in R Markdown. Reproduced from @Peikert2019.  "}
# file gets downloaded in Makefile
knitr::include_graphics("images/nutshell.svg", auto_pdf = TRUE)
```

# Setup

<!-- keep it brief, let `repro` do the work -->

We assume that you have already installed R and RStudio (if not check the `r link("https://github.com/aaronpeikert/repro-tutorial/blob/master/install.md", "installation guide")`).
Additionally, you'll need the [`repro`-package](https://github.com/aaronpeikert/repro)[^repropackage]:

[^repropackage]: https://github.com/aaronpeikert/repro

```r
# -- type this on the R console --
if(!requireNamespace("remotes"))install.packages("remotes")
remotes::install_github("aaronpeikert/repro")
library("repro")
```

The [`repro`-package](https://github.com/aaronpeikert/repro) contains several helpers to work with reproducibility tools.
For example, it can check if your computer is set up to use the tools we rely on:

```{r}
# -- type this on the R console --
check_git()
```

```{r}
# -- type this on the R console --
check_make()
```

```{r}
# -- type this on the R console --
check_docker()
```

If these commands detect that something is not installed or set up, they will give you detailed instructions (tailored to your operating system) to remedy the situation.
Follow the instructions, then rerun the command, until it tells you not to worry.

# Planing

<!-- researcher should begin early to enjoy most benefits -->
It can be tempting to leave considerations of reproducibility for when you finish a project.
<!-- weird sentence, I'll leave it as a placeholder-->
However, reproducibility is invaluable for collaboration---including with the version of yourself from a few weeks ago.
Therefore, we suggest starting early, ideally from the moment you decide to pursue a project to incorporate tools to help you archive reproducibility gradually.
The first step is to organize all files in one folder.
This way, you never lose anything, and you can easily share the files.
<!-- Hands-on: Introducing RProjects-->
RStudio's RProjects facilitate this concept of a project folder.
To create one, click on:

> File â†’ New Project... â†’ New Directory â†’ New Project

<!--Keep notes.-->
<!-- Hands on: Introduce Markdown -->
A great tool to capture ideas or meeting notes is Markdown.
To create a Markdown document click on: 

> File â†’ New File â†’ Markdown File

Markdown is simply text, where some characters let you add a minimal amount of structure:

```{r, results='asis', echo=FALSE}
# in case we want to reuse this example later
markdown_example <- "
<!--this is a Markdown file -->
# Header

Normal text.
Important **word**.

To do list:

* do research
* do more research
* spend time with family
"
cat("``` markdown", markdown_example, "```", sep = "")
```

We will later see how this simplicity enables us to create many different document formats (i.e. Word, PDF, HTML) and incorporate code (i.e. R, Python, Julia).
Another advantage of Markdown is that you can easily version-control it with Git.
You may be familiar with Microsoft Words' "Track Changes"-Feature and version control is similar in its basic idea but more potent in its features.
Instead of tracking only one file, you can keep track of the whole project directory, and instead of losing all changes when you agree to them, the entire history is preserved transparently.
For example this paper has been going through `r length(git2r::commits())` `r link("https://github.com/aaronpeikert/repro-tutorial/commits/master", "iterations")`.
To activate Git in a given project, you can call:
<!-- Hands-on: Introduce Git -->

```r
# `package::function()` â†’ use function from package without `library(package)`
usethis::use_git()
```

Recording each change you made helps you to iterate more quickly because you know that you can effortlessly go back to previous versions.
For example, you can write down a rough project idea, knowing your collaborators and you will iterate and improve.
<!-- This is maybe the place to introduce the example-->
First, you could create a new markdown file named `idea.md` that looks like this:

```markdown
<!--this is a Markdown file -->

# Hypothesis

Machiavellianism is higher in male persons.

# Analytic Strategy

t-test

# Sample

Could we use openpsychometrics.org data?
```

And you could commit it in Git:
<!--I am leaning towards doing everything in R, not sure though-->
<!--For Git we maybe should use RStudio's Git pane?-->

```r
git2r::add(".", "idea.md")
git2r::commit(".", "add a first concept")
```

But then you realize that the new literature suggests that there could be a bias in measurement:

``` markdown
<!--this is a Markdown file -->

# Hypothesis

Machiavellianism is higher in male persons.

# Analytic Strategy

Multigroup CFA + Measurement Invariance

# Sample

Could we use openpsychometrics.org data?
```

Commit this version:

```r
# -- type this on the R console --
git2r::add(".", "idea.md")
git2r::commit(".", "exclude bias in measurement as possible confounder")
```

And GitHub can show you what has changed, like in Figure \@ref(fig:idea-change).
GitHub is in its essence a Webinterface to Git and you may learn more about how to use it under the section on [GitHub].

```{r idea-change-screenshot, include=FALSE}
# unfortunately css selectors won't work for pdf so we'll use png instead
idea_change <- here::here("images", "idea-change.png")
webshot2::webshot("https://github.com/aaronpeikert/repro-tutorial/commit/5b3f4641ff542158184f85d458880c35e8f09f3c?diff=split",
                  file = idea_change,
                  selector = "div#diff-2f8beaa39e5c98706d8abb3361a8383776f8df8a195a21c0e6eeb25e5aa48f45", # only select file change
                  zoom = 2)# higher resolution
```


```{r idea-change, echo=FALSE, fig.cap="A screenshot of how a change tracked in Git is represented by GitHub.  ", out.width='100%'}
knitr::include_graphics(idea_change)
```

<!--I am troubled by how we should recommend to learn git-->
Git can be challenging to learn, because we are used to learn alone and Git is best learned with others.
We recommend to find a partner to attend an online lecture or workshop to learn the ins and outs of Git.

## Simulation (optional)

<!-- impress with neatness â†’ sample size planning, preregistration and analysis in one ðŸ˜Ž-->
<!-- but explain that good science is often not as neat, strive for the ideal -->

There are probably few things as frustrating as realizing that the data that you gathered cannot answer the research question you had in mind.
A step to prevent unpleasant surprises is to simulate data.
Simulated data lets you verify that the data you expect to gather and the analysis that you plan fit together.

<!--Hands-on: build simple functions tailored for your analysis-->

## Preregestration (optional)

A preregistration is a tool that may help to increase the credibility of empirical results.

<!--Hands on: Introduce RMarkdown-->
<!--Hands on: gitignore resulting .html/pdf-->
<!-- A preregistration needs to be public -->

## Prepare public release (optional)

One of the greatest benefits of open research is that other people can freely reuse materials.
To use your materials, they first have to find them and learn how to use them.
Interested users find out about your project via the readme.
The readme is the first thing they see when they visit your Project.
It should explain to them what your project is about and how to reproduce your project.
You could for example include the abstract of your (planned) paper here.

To add a readme to a repository run:

<!--Hands on: Add a readme-->
```r
usethis::use_readme_rmd()
```

This will create a file with the name `README.Rmd`.
When you knit this file, it in turn creates a `README.md`.
That means you can include R code or plots etc. within the readme.
The `README.md` file will look pleasant in the browser, just like in Figure \@ref(fig:readme).

```{r readme-screenshot, include=FALSE}
# unfortunately css selectors won't work for pdf so we'll use png instead
readme <- here::here("images", "readme.png")
webshot2::webshot("https://github.com/aaronpeikert/repro-tutorial/",
                  file = readme,
                  vwidth = 1920, # height & width are not resolution
                  vheight = 1080, # but what website thinks the browser size is
                  selector = "div#readme",
                  zoom = 2) # higher resolution
```

```{r readme, echo=FALSE, fig.cap="A screenshot of how a README.md is rendered/presented on GitHub.  ", out.width='100%'}
knitr::include_graphics(readme)
```

Even when other researchers are excited to use your code or materials, they are usually legally inhibited from to doing so.
That is because in many countries (i.e. the USA, European Union) the creator of something has exclusive right to use their creation.
A license allows other people to use what you have created.
<!---exact copy from our previous manuscript, do we need to change? -->
In our experience, the [Creative Commons - Attribution license (CC-BY)](https://creativecommons.org/licenses/by/4.0/) is often appropriate for sharing texts, R Markdown files, generated figures, and other media, whereas scripts and any other computer code are often best shared under the [MIT license](https://opensource.org/licenses/MIT) (or similar permissive licenses).
Both licenses assure maximal freedom for future users while requiring the attribution of the original authors in derivative work.
These licenses are also in line with the recommendations by the Reproducible Research Standard [@stoddenEnhancingReproducibilityComputational2016; @stoddenEnablingReproducibleResearch2009].
A great resource to choose a license is [choosealicense.com](https://choosealicense.com), however, no resource, including our recommendation, replaces legal advice.
<!-- plagiary end -->
It is important to get written consent from collaborators when you change/add the license.
However, if their first contribution occurs after you have added a license, they give their consent by contributing.
To add a CC-BY license to your project simply run (there are similar commands for other licenses):

<!--Hands on: Add a license-->
```r
usethis::use_ccby_license()
```

We strongly suggest that you strive for respectful interactions with anyone who might want to contribute.
In fact, we hope it comes naturally to you.
To communicate that contributors can expect a welcoming and respectful environment, you can add the `r link( "https://www.contributor-covenant.org", "Contributor Covenant")` to your repository.
The Contributor Covenant is a code of conduct used by many open source project.
Contributing to an open project is daunting and a public pledge to value any contributions (even when you do not incorporate them) can help others to take the first step.

To add the Contributor Covenant to your project use:

<!--Hands on: Add a code of conduct-->
```r
usethis::use_code_of_conduct()
```

If you have considered what you want to tell the public about the project with a readme, have chosen a license and thought about how to make collaboration welcoming, you may publish your Git repository.
See the section on [GitHub] on how to publish your project.

## Collaboration

Often, reproducibility is reduced to the merits it has for the reader.
However, we argue that reproducibility is vital for collaboration, not only in the sense that the consumer of a scientific product build upon it, but also that the creators work together.
The time that you invest into ensuring reproducibility, is directed at ensuring effective collaboration.
Therefore, reproducibility is at its core about collaboration.

### GitHub

On your local machine, you use Git to track changes.
However, to share these changes with others, you need to use an online service like GitHub.
GitHub is not the only solution; there is also [GitLab](gitlab.com) or [BitBucket](https://bitbucket.org), which are as feature-rich as GitHub.
GitLab has the advantage that your institution can host it themselves; therefore, you are not relying on commercial service providers.
We focus on GitHub because it is the most popular service.
To upload your changes to GitHub, you need to create an account under https://github.com/join.
As a researcher, you are eligible for the `r link("https://help.github.com/en/articles/applying-for-an-educator-or-researcher-discount", "Researcher/Educator discount").
The following command creates a new GitHub repository under your GitHub account, beware this is public:
<!--Hands-on: Introduce Github-->

```r
usethis::use_github()
```

To create a private repository (only you and people you invite have access), use:

```r
usethis::use_github()
```

<!--Hands on: Introduce GitHub Issues-->
<!--Hands on: Introduce GitHub Projects-->

# Analyzing Data

## Internal Dependencies

A well defined "entry point" that automatically reproduces everything eases collaboration.

<!--I am not sure this is the right place, should we introduce this earlier? -->

<!--Hands on: Introduce Make-->
<!--Hands on: Add targets for README.Rmd, preregistration.Rmd -->

``` r
automate_make()
```

## External Dependencies

A considerable number of external dependencies may hinder collaboration and long term reproducibility, but automated solutions can "bundle" and fix dependencies.

<!-- Hands on: Introduce Docker -->

``` r
automate_docker()
```

<!-- after this everything is optional? -->

### renv (alternative)

### Singularity (optional)
<!-- Hands on: add data via automate() -->
<!-- Hands on: automatically download data via manually editing the Makefile -->

## Data Integrity (optional)

<!-- Hands-on: check changed hash -->

## Anonymising Data (optional)

<!-- Should we add a section on synthetic data generation? -->
<!-- Hands on: Create synthetic data -->

## Releasing a Preprint (optional)

<!-- Hands on: add commit hash to results-->
<!-- Hands on: git tag + github release-->

# Peer Review (optional)

# Post Publication Review (optional)

# Archiving

<!-- Hands on: explain how to archive data-->
<!-- Hands on: explain how to archive docker images-->

# Checklist

<!-- Should we design a checklist? -->

```{r, results='asis', echo=FALSE}
link_index()
```

# References
